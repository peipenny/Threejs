<!DOCTYPE html>
<html>
<head>
<style>
#heading {
    position : absolute;
    text-align : center;
    width : 100vw;
    bottom : 80vh;
}
</style>
</head>
<body> 

<div id='heading'>
  <button id='click'> Stop </button>
</div>


	<script src="https://threejs.org/build/three.min.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
	</script>
	<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
	<script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/DDSLoader.js"></script>
	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
	<script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>

<script>

var tg = 0 ;
$('#click').click(function(){
	tg=! tg;
	if(tg==1)cancelAnimationFrame(ani);
	else animate();
});

var renderer,camera,scene;
var truck= new THREE.Object3D();;
var raycaster;
var pickables = [];
var base, bases = [];
var myLine = null;

//var a = new THREE.Vector3();
var p = [];

var steps,numStep,moveTo,theta2;
var v,dq,front,now,next,ds;
var isWalking;

init();
animate();


function readModel (modelName, targetSize=40) {

  var onProgress = function(xhr) {
    if (xhr.lengthComputable) {
      var percentComplete = xhr.loaded / xhr.total * 100;
      console.log(Math.round(percentComplete, 2) + '% downloaded');
    }
  };

  var onError = function(xhr) {};

  var mtlLoader = new THREE.MTLLoader();
  mtlLoader.setPath('models/');
  mtlLoader.load(modelName+'.mtl', function(materials) {

    materials.preload();

    var objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.setPath('models/');
    objLoader.load(modelName+'.obj', function(object) {
		
		let theObject =  unitize (object, targetSize);
		theObject.add ( new THREE.BoxHelper (theObject) )
		theObject.name = 'OBJ'
		
		truck.add(theObject);
		
		scene.add (truck);
		
		truck.position.set(0,0,0);
	

    }, onProgress, onError);

  });

}

function unitize (object, targetSize) {  
	
	// find bounding box of 'object'
	var box3 = new THREE.Box3();
	box3.setFromObject (object);
	var size = new THREE.Vector3();
	size.subVectors (box3.max, box3.min);
	var center = new THREE.Vector3();
	center.addVectors(box3.max, box3.min).multiplyScalar (3);	///更改位置
	
	console.log ('center: ' + center.x + ', '+center.y + ', '+center.z );
	console.log ('size: ' + size.x + ', ' +  size.y + ', '+size.z );
	
	// uniform scaling according to objSize
	var objSize = Math.max (size.x, size.y, size.z);
	var scaleSet = targetSize/objSize;
				
	var theObject =  new THREE.Object3D();
	theObject.add (object);
	object.scale.set (scaleSet, scaleSet, scaleSet);
	object.position.set (-center.x*scaleSet, -center.y*scaleSet, -center.z*scaleSet);
	
	return theObject;
			
}

function init(){

	renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.setSize (window.innerWidth,window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);
	
	camera = new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,1000);
	camera.position.z = 50; // (0,0,50)

	var controls = new THREE.OrbitControls(camera, renderer.domElement);

	scene = new THREE.Scene();
	var grid = new THREE.GridHelper(300,10,'red','white');
	scene.add(grid);
	
	
	/// objloader
	readModel('truck');
	
	///------light
	/*
	pointLight = new THREE.PointLight(0x404040,20,300);
	pointLight.position.set(100,50,100);
	scene.add(pointLight);
	*/
	 var ambient = new THREE.AmbientLight(0x444444);
	scene.add(ambient);
	var directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(0, 0, 1).normalize();
	scene.add(directionalLight);

	var pointLight = new THREE.PointLight (0xffffff);
	pointLight.position.set (100,200,-100);
	scene.add (pointLight);

	//------------- touch
	
	plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.5,
    visible: true
	}));
	scene.add(plane);
	plane.rotation.x = -Math.PI / 2;
	pickables = [plane];
	plane.material.visible = false;

	base = new THREE.Mesh(new THREE.CircleGeometry(10, 10), new THREE.MeshNormalMaterial());	//建立點

	raycaster = new THREE.Raycaster();
	document.addEventListener('pointerdown', onDocumentMouseDown, false);
	//---------

}


function makeLine(startPoint) {
	const MAX_LINE_POINTS = 100;
	  
	var geometry = new THREE.Geometry();
		
	for (var i = 0; i < MAX_LINE_POINTS; i++) {
		geometry.vertices.push(startPoint.clone());
	}

	myLine =  new THREE.Line(geometry,  new THREE.LineBasicMaterial( { color: 0xffff00 } ));

	return myLine;
}

function addPoint(myPoint) {
	myLine.geometry.vertices.shift();
	myLine.geometry.vertices.push (myPoint);
	myLine.geometry.verticesNeedUpdate = true;
}

var toggle = 1; 
var start = 1 ;

function onDocumentMouseDown(event) {

	var mouse = new THREE.Vector2();
	var btnNum = event.button;	//確認是左鍵還是右鍵
	if(btnNum==0&&toggle==1){
			
		  event.preventDefault();
		  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		
		  // find intersections
		  raycaster.setFromCamera(mouse, camera);
		  var intersects = raycaster.intersectObjects(pickables);

			var a = intersects[0].point;
			p.push(a);
			if(start==1){
				p.push(a);
				start = 0;
			}
		  if (intersects.length > 0) {
				let bb = base.clone();
				bb.position.copy (intersects[0].point);
				bb.rotation.x = -Math.PI/2;
				scene.add (bb);
					bases.push (bb);
				if (myLine === null) {
					myLine = makeLine (bb.position);
				  scene.add (myLine);
				} else {
					addPoint(bb.position);
				}
			}
	}
	if(btnNum==2){
		document.addEventListener('contextmenu', event => event.preventDefault());
		toggle = 0;
		truck.position.copy(p[0]);
		//// init
		
		front = p.length - 1; 
		now = 0;	
		next = 1;
		isWalking = true;
		walkingInit();
		
	}
}

function walkingInit(){
	v = p[next].clone().sub(p[now]);   //v = p[next]-p[now]
	ds = 0.51;							//走的速度
	steps = Math.floor(v.length()/ds);	//	floor為四捨五入 
	moveTo = p[now].clone();
	stepNum = 0 ;
}


function walking(){
	moveTo = moveTo.clone().add(v.clone().setLength(ds)); //將此向量設置為與該向量具有相同方向但長度為l的向量。
	stepNum++;
	if(stepNum > steps){		//如果走的步數已經超過應該走的步數

		truck.position.copy(p[next]);
		front++;
		now++;
		next++;
		front %= p.length;
		now %= p.length;
		next %= p.length;
		rotatingInit();
		isWalking=false;
	}
	else truck.position.copy(moveTo);
}

function rotatingInit(){
	
	var p12 = p[now].clone().sub(p[front]);	 	//現在的角度-之前的角度
	var theta1 = Math.atan2(p12.x,p12.z);
	//truck.position.copy(p[now]);
	truck.rotation.y = theta1;   
	
	var p23 = p[next].clone().sub(p[now]); 		//下一個角度-現在的角度
	theta2 = Math.atan2(p23.x,p23.z);
	
	dq = 0.05;					//轉的速度
	
	if (theta2 < 0) { 		// 異號
		theta2 += Math.PI * 2;
	 }
	  
	if (theta1 < 0) { // 異號
		theta1 += Math.PI * 2;
	}
	  
	if(theta1 > theta2){
		if(theta1 - Math.PI > theta2){
			steps = Math.floor ((Math.PI * 2 - (theta1-theta2))/dq);
		}
		else {
			steps = Math.floor ((theta1-theta2)/dq);
			dq = -dq;
		}
	}
	else {
		if(theta2 - Math.PI > theta1){
			steps = Math.floor ((Math.PI * 2 - (theta2-theta1))/dq);
			dq = -dq;
		}
		else {
			steps = Math.floor ((theta2-theta1)/dq);
		}
	 }
	 
	//debugger 
	numStep = 0;
	moveTo = theta1 ; // theta1
}

function rotating(){
	if(numStep > steps){
		truck.rotation.y = theta2; //theta2
		walkingInit();
		isWalking=true;
	}
	else{
		truck.rotation.y = moveTo; //moveTo
		moveTo +=dq;
		++numStep;
	}
}

var ani;
function animate(){

	if(isWalking)walking();
	else rotating();
	
	renderer.render(scene,camera);
	ani = requestAnimationFrame(animate);
}
	


</script>
</body>
</html>

